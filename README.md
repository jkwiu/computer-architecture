# computer-architecture
프로그래밍 관점에서 보는 컴퓨터 구조

1. 컴퓨터 구조 개론
   1. 하드웨어
      1. 중앙처리장치(CPU)
      2. 주기억 장치(main memory)
      3. 입출력 장치(I/O devices)
   2. 시스템 소프트웨어(OS)
   3. 응용 프로그램
2. 논리 회로 관점에서의 컴퓨터 구조
   1. LSB(Least Significant Bit) : 가장 오른쪽의 비트, 가정 덜 중요한 비트
   2. MSB(Most Significant Bit): 가장 왼쪽의 비트, 가장 중요한 비트
   3. CPU의 가장 기본적인 연산은 덧셈이다. 덧셈기 하드웨어를 만들고 이를 수정해서 뺄셈기로 사용하고, 덧셈을 반복적으로 수행해서 곱셈, 뺄셈을 반복적으로 수행해서 나눗셈을 수행한다.
      1. 하지만 실제로 컴퓨터에서는 정수표현에서 부호와 절대값 방식을 사용하면 느리므로, **보수표현(complement representation)**을 사용한다.
   4. 2의 보수표현(two's complement binary representation)
      1. 2의 보수
         1. 서로 더해서 0이 되는 숫자 사이의 관계를 보수관계라 한다.
      2. **MSB가 1이면 음수, 0이면 0또는 양수다.**
      3. +10<sub>(2)</sub>의 2의 보수인 -10<sub>(2)</sub>을 찾으려면
         1. 0에서 10을 빼야 하는데 0에서 1을 뺄 수 없기 때문에 먼저 0000 1010<sub>(2)</sub>에서 1<sub>(2)</sub>을 빼서 1111 1111<sub>(2)</sub>로 만든 뒤에 10을 뺀후 1<sub>(2)</sub>을 더해준다.
         2. 위의 과정은 NOT을 취한 후 1<sub>(2)</sub>을 더해주는 것과 같다.
      4. NOT 연산
         1. 2진수에서의 NOT연산은 비트를 반전시키는 것을 말한다.
      5. 특징
         1. 부호가 없이 음수를 표현할 수 있다.
         2. **보수표현은 부호라는 개념을 전혀 고려하지 않는 방식이다. 컴퓨터 입장에서는 그냥 계산하면 된다.**
   5. 2의 보수 표현이 나타내는 10진수 숫자를 알고 싶다면?
      1. MSB가 0이면 비트들의 절대값
      2. MSB가 1이면 2의 보수를 구한 값에 ``-``를 붙이면 된다
   6. 정수 연산
      1. 덧셈
         1. LSB에서 MSB방향으로 차례로 더하면 된다. 부호를 고려할 필요가 없다.
      2. 뺄셈
         1. 2의 보수를 이용하여 덧셈으로 변환한 후 연산한다.
      3. 곱셈
         1. 10진법 곰셈과 동일
      4. 나눗셈
         1. 뺄셈을 반복적으로 해서 더 이상 뺄셈이 안될 때까지 수행한다.
   7. 실수의 표현 방법
      1. 고정 소수점 표현(fixed-point representation)
         1. 숫자 표현이 간단하기 때문에 연산 속도가 빠르지만, 일반적인 컴퓨터에서는 이 방식을 사용하지 않고, 절대값이 아주 큰 숫자거나 소수점 아래가 아주 길어서 정확한 실수 값을 사용하지 않는 경우에 제한적으로 사용한다.
      2. 부동 소수점 표현(floating-point representation)
         1. 0.34<sub>10</sub>를 컴퓨터에서 내부적으로 표현
         2. 2진수로 변환
            1. 0.010101110...<sub>2</sub>
         3. 정규형(normalized form)으로 변환
            1. 1.0101110 x 2<sup>-2</sup>
               1. ``부호 | 지수 | 가수`` 의 위치로 표현
                  1. 부호는 양수이므로 0
                  2. 8비트를 사용하여 실수를 표현하는 경우에 부호 1비트, 지수 3비트, 가수 3비트를 할당한다고 가정한다.
                  3. 지수를 위해 3비트를 할당할 때는 지수를 ``3 초과표현(excess 3 representation)``으로 표기한다
                     1. 지수가 -2기 때문에 -2 + 3하여 1로 적는다.
                  4. 가수는 4비트밖에 없으므로 앞에서부터 4비트를 선택하여 1010이 된다.
                  5. 0001 1010<sub>2</sub>가 된다.
         4. 위의 결과값을 10진수로 바꾸면 0.3125가 되는데 오차가 발생한다.
      3. 초과표현
         1. 표현하고자 하는 수보다 3을 초과시키면 ``3 초과 표현``
         2. 음수와 양수를 균등하게 표현하기 위해서 3 초과 표현을 사용한다. 
         3. 1.000 x 2<sup>0</sup>과 11.111 x 2<sup>-1</sup>을 비교할 때, 10진수로 바꿔서 비교하거나, 지수를 동일하게 맞추는 방법이 있다.
         4. 하지만, 정규형에서는 지수를 맞추는 과정을 거칠 필요도 없다.
         5. 1.000 x 2<sup>0</sup>과 1.111 x 2<sup>-1</sup>을 비교해보자.
         6. 위와 같이 정규형에서는 가수를 볼 필요가 없다. 가수가 아무리 커도 언제나 2 미만의 값이기 때문이다. 그러므로 지수만 비교하면 된다. 물론 지수의 값이 같으면 가수의 값을 비교한다.
         7. 위의 두 수를 8비트를 사용하여 표현한 뒤 MSB부터 오른쪽으로 한 비트씩 비교하는 방식으로 대소를 비교하면 된다.
         8. **이처럼 지수영역을 초과표현을 사용하면 같은 부호일 경우 정수처럼 생각해도 대소관계를 파악할 수 있다.**
            1. 실수의 연산보다 정수의 연산이 컴퓨터에서 더 빠르다.
      4. 히든 비트
         1. 어차피 정규형으로 변환하면 정수 부분은 무조건 1이기 때문에 이부분을 표현하지 않으면 소수점 한자리를 더 표현할 수 있다.
      5. Special Values
         1. 특정 값을 지정해두는 것을 약속한 값
         2. 가장 작은 절대값의 양의 실수는 0.1328125
         3. 가장 큰 절대값의 양의 실수는 31.0
         4. 위의 두 값을 보면 0.0 ~ 0.1328125와 같은 구간에서는 공백이 생기고 이 영역이 계산될 때는 overflow 혹은 underflow가 발생한다.
      6. 부동 소수점 연산
         1. 지수를 똑같이 맞춰주고
         2. 가수들의 덧셈 연산
         3. 결과값을 정규화
      7. 문자의 표현
         1. 아스키 코드
      8. 